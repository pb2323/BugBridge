"""
Reporting Workflow

LangGraph workflow for generating daily summary reports.
"""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from typing import Any, Dict, Literal, Optional, TypedDict

from langgraph.graph import END, StateGraph

from bugbridge.agents.reporting import ReportingAgent, get_reporting_agent
from bugbridge.utils.logging import get_logger

logger = get_logger(__name__)


class ReportingState(TypedDict, total=False):
    """
    State for the reporting workflow.

    Attributes:
        report_date: Date for which to generate the report (defaults to yesterday).
        report_id: ID of the generated report (after generation).
        report_content: Formatted Markdown report content.
        metrics: Aggregated daily metrics.
        summary: Natural language summary generated by LLM.
        errors: List of error messages.
        timestamps: Dictionary of timestamps for workflow steps.
        metadata: Additional metadata for the workflow.
    """

    report_date: datetime
    report_id: Optional[str]
    report_content: Optional[str]
    metrics: Optional[Dict[str, Any]]
    summary: Optional[Dict[str, Any]]
    errors: list[str]
    timestamps: Dict[str, datetime]
    metadata: Dict[str, Any]


async def generate_report_node(state: ReportingState) -> ReportingState:
    """
    LangGraph node function for generating daily report.

    Args:
        state: Current reporting workflow state.

    Returns:
        Updated state with generated report data.
    """
    agent = get_reporting_agent()

    # Get report date from state or default to yesterday
    report_date = state.get("report_date")
    if report_date is None:
        report_date = (datetime.now(UTC) - timedelta(days=1)).replace(
            hour=0, minute=0, second=0, microsecond=0
        )

    logger.info(
        f"Generating daily report for {report_date.strftime('%Y-%m-%d')}",
        extra={"report_date": report_date.isoformat()},
    )

    try:
        # Generate report
        result = await agent.generate_daily_report(report_date)

        # Update state with report data
        state["report_id"] = result["report_id"]
        state["report_content"] = result["content"]
        state["metrics"] = result["metrics"]
        state["summary"] = result["summary"]
        state["report_date"] = report_date

        # Update timestamps
        if "timestamps" not in state:
            state["timestamps"] = {}
        state["timestamps"]["report_generated_at"] = datetime.now(UTC)

        logger.info(
            f"Successfully generated daily report (ID: {result['report_id']})",
            extra={"report_id": result["report_id"]},
        )

        return state

    except Exception as e:
        error_msg = f"Failed to generate report: {str(e)}"
        logger.error(
            error_msg,
            extra={"report_date": report_date.isoformat()},
            exc_info=True,
        )

        if "errors" not in state:
            state["errors"] = []
        state["errors"].append(error_msg)

        return state


def create_reporting_workflow() -> StateGraph:
    """
    Create and configure the Reporting LangGraph workflow.

    Returns:
        Compiled StateGraph workflow ready for execution.
    """
    # Create StateGraph with ReportingState
    workflow = StateGraph(ReportingState)

    # Add node
    workflow.add_node("generate_report", generate_report_node)

    # Set entry point
    workflow.set_entry_point("generate_report")

    # Complete workflow
    workflow.add_edge("generate_report", END)

    return workflow


def compile_reporting_workflow() -> Any:
    """
    Compile the Reporting workflow for execution.

    Returns:
        Compiled workflow application.
    """
    workflow = create_reporting_workflow()
    return workflow.compile()


# Create a global compiled workflow instance
_reporting_app: Any = None


def get_reporting_workflow_app() -> Any:
    """
    Get or create the compiled reporting workflow application.

    Returns:
        Compiled reporting workflow application instance.
    """
    global _reporting_app
    if _reporting_app is None:
        _reporting_app = compile_reporting_workflow()
    return _reporting_app


async def execute_reporting_workflow(
    report_date: Optional[datetime] = None,
    config: Optional[Dict[str, Any]] = None,
) -> ReportingState:
    """
    Execute the Reporting workflow with error handling.

    Args:
        report_date: Date for which to generate report (defaults to yesterday).
        config: Optional runtime configuration for workflow execution.

    Returns:
        Final workflow state after execution.
    """
    if report_date is None:
        report_date = (datetime.now(UTC) - timedelta(days=1)).replace(
            hour=0, minute=0, second=0, microsecond=0
        )

    initial_state: ReportingState = {
        "report_date": report_date,
        "report_id": None,
        "report_content": None,
        "metrics": None,
        "summary": None,
        "errors": [],
        "timestamps": {},
        "metadata": {},
    }

    try:
        logger.info(
            "Starting reporting workflow execution",
            extra={
                "report_date": report_date.isoformat(),
            },
        )

        app = get_reporting_workflow_app()
        result = await app.ainvoke(initial_state, config=config)

        logger.info(
            "Reporting workflow execution completed",
            extra={
                "report_date": report_date.isoformat(),
                "report_id": result.get("report_id"),
                "has_errors": len(result.get("errors", [])) > 0,
            },
        )

        return result

    except Exception as e:
        logger.error(
            f"Reporting workflow execution failed: {str(e)}",
            exc_info=True,
        )
        # Return state with error
        return {
            **initial_state,
            "errors": initial_state.get("errors", []) + [f"Workflow execution failed: {str(e)}"],
        }


__all__ = [
    "create_reporting_workflow",
    "compile_reporting_workflow",
    "get_reporting_workflow_app",
    "execute_reporting_workflow",
    "generate_report_node",
    "ReportingState",
]

